import fs from 'node:fs/promises';
import type { ResolvedModule } from '@callstack/polygen-project';
import { Module } from '@callstack/wasm-parser';
import { computeChecksumBuffer } from '../helpers/checksum.js';
import { W2CExternModule, W2CGeneratedModule } from './modules.js';
import type { ResolvedModuleImport } from './types.js';
import { buildGeneratedSymbol } from './utils.js';

/**
 * Holds aggregate codegen state.
 *
 * Contains methods to progressively build the codegen state.
 */
export class CodegenContext {
  /**
   * List of generated modules
   */
  public modules: W2CGeneratedModule[] = [];

  /**
   * List of imported modules
   *
   * Generated by processing imports of generated modules
   */
  public importedModules: Map<string, W2CExternModule> = new Map();

  /**
   * Adds a module to the context.
   *
   * This method should be used to add new modules to the context.
   * Before creating a new W2CModule, module body is scanned for imports and
   * all imported modules are added to the context into `importedModules`.
   *
   * This way, when creating the module, all imported modules can be resolved.
   */
  public async addModule(
    module: ResolvedModule
  ): Promise<[W2CGeneratedModule, W2CExternModule[]]> {
    const moduleContents = await fs.readFile(module.resolvedPath, {
      encoding: null,
    });
    const checksum = computeChecksumBuffer(moduleContents.buffer);
    const moduleBody = new Module(moduleContents.buffer as ArrayBuffer);
    const importedModules = this.processImportedModules(moduleBody);

    const generatedModule = new W2CGeneratedModule(
      this,
      moduleBody,
      checksum,
      module.resolvedPath,
      module
    );
    this.modules.push(generatedModule);

    return [generatedModule, importedModules];
  }

  /**
   * Gets an imported module by name.
   *
   * If the module is not found, an error is thrown.
   *
   * @param name Name of the imported module
   */
  public getImportedModule(name: string): W2CExternModule {
    const externModule = this.importedModules.get(name);
    if (!externModule) {
      throw new Error(`Imported Module ${name} not found`);
    }
    return externModule;
  }

  /**
   * Gets or creates an imported module by name.
   *
   * If the module is not found, an empty one is created.
   *
   * @param name Name of the imported module
   */
  public getOrCreatedImportedModule(name: string): W2CExternModule {
    let externModule = this.importedModules.get(name);
    if (!externModule) {
      externModule = new W2CExternModule(name);
      this.importedModules.set(name, externModule);
    }

    return externModule;
  }

  public resolveImport(
    moduleName: string,
    symbolName: string
  ): ResolvedModuleImport | undefined {
    return this.getImportedModule(moduleName)?.exports.get(symbolName);
  }

  private processImportedModules(body: Module): W2CExternModule[] {
    const importsByModuleName = Object.groupBy(body.imports, (el) => el.module);

    return Object.entries(importsByModuleName).map(([moduleName, imports]) => {
      const module = this.getOrCreatedImportedModule(moduleName);

      const resolvedSymbols = (imports ?? []).map((el) =>
        buildGeneratedSymbol(module, el)
      );
      for (const resolvedSymbol of resolvedSymbols) {
        module.addSymbol(resolvedSymbol);
      }

      return module;
    });
  }
}

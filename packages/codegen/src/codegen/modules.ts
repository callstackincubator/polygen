import path from 'node:path';
import type { PolygenModuleConfig } from '@callstack/polygen-config';
import type { Module, ModuleMemory, ModuleTable } from '@callstack/wasm-parser';
import { mangleModuleName } from '../wasm2c/mangle.js';
import type { CodegenContext } from './context.js';
import type {
  GeneratedModuleFunction,
  GeneratedSymbol,
  ResolvedModuleImport,
} from './types.js';
import { buildGeneratedSymbol } from './utils.js';

/**
 * Base class for all modules types.
 *
 * There are two types of modules in the codegen:
 * - `W2CExternModule` - represents an imported module
 * - `W2CGeneratedModule` - represents a generated module wrapping a WebAssembly module.
 */
export abstract class W2CModuleBase {
  /**
   * Original name of the imported module.
   *
   * If module name is not passed, it defaults to module file name without the extension.
   *
   * Unsafe to use as a symbol in source code, use `mangledName` instead.
   */
  public readonly name: string;

  /**
   * Mangled name of the imported module.
   *
   * Safe to use in source code as a symbol name.
   */
  public readonly mangledName: string;

  public constructor(name: string) {
    this.name = name;
    this.mangledName = mangleModuleName(name);
  }

  /**
   * Gets the C typename that was generated by wasm2c for this imported module.
   */
  get generatedContextTypeName(): string {
    return `w2c_${this.mangledName}`;
  }
}

/**
 * Represents an imported module in the shared context.
 *
 * This represents an imported module with imported symbols across all generated modules.
 *
 * Modules of this type have no implementation in WASM file, but the code for those modules
 * must be generated to allow defining them from JS code.
 */
export class W2CExternModule extends W2CModuleBase {
  /**
   * All symbols required to be provided.
   *
   * Generated based on imports of this module from another modules.
   */
  public readonly exports: Map<string, GeneratedSymbol>;

  public constructor(name: string) {
    super(name);
    this.exports = new Map();
  }

  /**
   * Gets the name of the field in the root context struct.
   *
   * Each generated module that imports this module contains a field that holds
   * the imported module instance.
   */
  public get generatedRootContextFieldName(): string {
    return `import_${this.mangledName}Ctx`;
  }

  public addSymbol(symbol: GeneratedSymbol) {
    this.exports.set(symbol.localName, symbol);
  }
}

/**
 * Represents a generated module wrapping a WebAssembly module.
 *
 * This class is created for each WebAssembly module that is processed by the `wasm2c` tool.
 */
export class W2CGeneratedModule extends W2CModuleBase {
  /**
   * Path to the file that the metadata was loaded from.
   */
  public readonly sourceModulePath: string;

  /**
   * SHA-256 checksum of module contents
   */
  public readonly checksum: Buffer;
  public readonly generatedClassName: string;

  /**
   * Parsed WebAssembly module instance.
   */
  public readonly body: Module;

  /**
   * Map of module imports
   */
  public readonly moduleImports: Record<string, W2CExternModule>;

  /**
   * Collection of generated module imports made by `wasm2c` tool.
   */
  public readonly imports: ResolvedModuleImport[];

  /**
   * Collection of generated module exports made by `wasm2c` tool.
   */
  public readonly exports: GeneratedSymbol[];

  constructor(
    context: CodegenContext,
    body: Module,
    checksum: Buffer,
    sourceModulePath: string,
    moduleSpec: PolygenModuleConfig
  ) {
    const name =
      moduleSpec.wasm2c?.moduleName ?? path.basename(sourceModulePath, '.wasm');
    super(name);

    this.body = body;
    this.sourceModulePath = sourceModulePath;
    this.generatedClassName = capitalize(mangleModuleName(name));
    this.checksum = checksum;
    this.moduleImports = processImportedModulesInfo(this.body, context);
    this.imports = resolveImports(context, this.body);
    this.exports = processExports(this, this.body);
  }

  /**
   * Retrieves a reversed array of all imported modules.
   *
   * @return An array containing the imported modules in reverse order.
   */
  public get importedModules() {
    return Object.values(this.moduleImports).toSorted((a, b) =>
      a.name.localeCompare(b.name)
    );
  }

  /**
   * Retrieves an array of all exported memories.
   */
  public get exportedMemories(): GeneratedSymbol<ModuleMemory>[] {
    return this.exports.filter(
      (i) => i.target.kind === 'memory'
    ) as GeneratedSymbol<ModuleMemory>[];
  }

  /**
   * Retrieves an array of all exported functions.
   */
  public get exportedFunctions(): GeneratedSymbol<GeneratedModuleFunction>[] {
    return this.exports.filter(
      (i) => i.target.kind === 'function'
    ) as GeneratedSymbol<GeneratedModuleFunction>[];
  }

  /**
   * Retrieves an array of all exported tables.
   */
  public get exportedTables(): GeneratedSymbol<ModuleTable>[] {
    return this.exports.filter(
      (i) => i.target.kind === 'table'
    ) as GeneratedSymbol<ModuleTable>[];
  }
  /**
   * Name of the function that creates a new instance of the module.
   */
  public get moduleFactoryFunctionName(): string {
    return `get${this.generatedClassName}Module`;
  }

  /**
   * Name of the class that represents the module context.
   */
  public get contextClassName(): string {
    return `${this.generatedClassName}ModuleContext`;
  }
}

function processImportedModulesInfo(
  module: Module,
  codegenContext: CodegenContext
) {
  const importedModuleNames = new Set(
    module.imports.values().map((i) => i.module)
  );

  const importsInfo = importedModuleNames
    .values()
    .map((moduleName): [string, W2CExternModule] => [
      moduleName,
      codegenContext.getImportedModule(moduleName),
    ]);

  return Object.fromEntries(importsInfo);
}

function resolveImports(codegenContext: CodegenContext, moduleBody: Module) {
  return moduleBody.imports.map(
    (el): ResolvedModuleImport =>
      codegenContext.resolveImport(el.module, el.name)!
  );
}

function processExports(module: W2CGeneratedModule, moduleBody: Module) {
  return moduleBody.exports.map(
    (el): GeneratedSymbol => buildGeneratedSymbol(module, el)
  );
}

function capitalize(name: string) {
  return name.charAt(0).toUpperCase() + name.slice(1);
}

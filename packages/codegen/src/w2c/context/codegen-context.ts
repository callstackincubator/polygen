import type {
  GeneratedExport,
  GeneratedFunctionExport,
  GeneratedFunctionInfo,
  GeneratedImport,
} from '../types.js';
import { mangleModuleName, mangleName } from '../mangle.js';
import { Module, type ModuleMemory } from '@callstack/wasm-parser';
import type { ModuleFunction, ValueType } from '@callstack/wasm-parser';

type ImportMap = Record<string, W2CCodegenLocalImportedModule>;

/**
 * The `W2CModuleCodegenContext` class is responsible for maintaining the state and metadata
 * related to the code generation process of a WebAssembly (WASM) module using the `wasm2c` tool.
 * This class stores information about module imports and exports, and provides utilities
 * for handling the generated module code.
 */
export class W2CModuleCodegenContext {
  /**
   * Collection of imported modules and their mangled names.
   */
  public readonly moduleImports: ImportMap = {};

  /**
   * Mangled module name, safe to use in source code as a symbol name.
   */
  public readonly mangledName: string;

  /**
   * Collection of generated module imports made by `wasm2c` tool.
   */
  public readonly imports: GeneratedImport[];

  /**
   * Collection of generated module exports made by `wasm2c` tool.
   */
  public readonly exports: GeneratedExport[];

  constructor(name: string, module: Module) {
    this.mangledName = mangleModuleName(name);
    this.moduleImports = processImportedModulesInfo(module);
    this.imports = processImports(this, module);
    this.exports = processExports(this, module);
  }

  /**
   * Gets a C typename that was generated by wasm2c for this module.
   */
  public get generatedContextTypeName(): string {
    return `w2c_${this.mangledName}`;
  }

  /**
   * Retrieves a reversed array of all imported modules.
   *
   * @return An array containing the imported modules in reverse order.
   */
  public get importedModules() {
    return Object.values(this.moduleImports).toReversed();
  }

  /**
   * Retrieves an array of all exported memories.
   */
  public get exportedMemories(): GeneratedExport<ModuleMemory>[] {
    return this.exports.filter(
      (i) => i.target.kind === 'memory'
    ) as GeneratedExport<ModuleMemory>[];
  }

  /**
   * Retrieves an array of all exported functions.
   */
  public get exportedFunctions(): GeneratedFunctionExport[] {
    return this.exports.filter(
      (i) => i.target.kind === 'function'
    ) as GeneratedFunctionExport[];
  }
}

/**
 * Represents a WebAssembly to C (W2C) imported module with details about its name and mangled name.
 *
 * This class provides functionalities to handle and retrieve the context type
 * and root context field names for the imported module based on its mangled name.
 *
 * @remarks The mangled name is derived from the original module name through a specific mangle transformation.
 */
export class W2CCodegenLocalImportedModule {
  /**
   * Original name of the imported module.
   */
  public readonly name: string;

  /**
   * Mangled name of the imported module.
   */
  public readonly mangledName: string;

  constructor(name: string) {
    this.name = name;
    this.mangledName = mangleModuleName(name);
  }

  /**
   * Gets the C typename that was generated by wasm2c for this imported module.
   */
  get generatedContextTypeName(): string {
    return `w2c_${this.mangledName}`;
  }

  /**
   * Gets the name of field of root context struct, that was generated by wasm2c for this imported module.
   */
  get generatedRootContextFieldName(): string {
    return `import_${this.mangledName}Ctx`;
  }
}

function processImportedModulesInfo(module: Module) {
  const importedModuleNames = new Set(
    module.imports.values().map((i) => i.module)
  );

  const importsInfo = importedModuleNames
    .values()
    .map((name): [string, W2CCodegenLocalImportedModule] => [
      name,
      new W2CCodegenLocalImportedModule(name),
    ]);

  return Object.fromEntries(importsInfo);
}

function processImports(context: W2CModuleCodegenContext, module: Module) {
  return module.imports.map((el): GeneratedImport => {
    const importInfo = context.moduleImports[el.module];
    if (!importInfo) {
      throw new Error(
        `Assert error: could not get import info for ${el.module}`
      );
    }

    const generatedFunctionName = mangleFunction(
      el.name,
      importInfo.mangledName
    );

    switch (el.target.kind) {
      case 'function':
        return {
          ...el,
          ...buildGeneratedFunctionInfo(el.target),
          mangledName: mangleName(el.name),
          moduleInfo: importInfo,
          generatedFunctionName,
        };
      default:
        return {
          ...el,
          mangledName: mangleName(el.name),
          moduleInfo: importInfo,
          generatedFunctionName,
        };
    }
  });
}

function processExports(context: W2CModuleCodegenContext, module: Module) {
  return module.exports.map((el): GeneratedExport => {
    const mangledName = mangleName(el.name);
    const generatedFunctionName = mangleFunction(el.name, context.mangledName);

    switch (el.target.kind) {
      case 'function':
        return {
          ...el,
          ...buildGeneratedFunctionInfo(el.target),
          generatedFunctionName,
          mangledName,
        };
      default:
        return {
          ...el,
          mangledName,
          generatedFunctionName,
        };
    }
  });
}

function mangleFunction(name: string, mangledModule: string) {
  return `w2c_${mangledModule}_${mangleName(name)}`;
}

function buildGeneratedFunctionInfo(
  func: ModuleFunction
): GeneratedFunctionInfo {
  const returnType = matchW2CRType(func.resultTypes[0]);

  return {
    parameterTypeNames: func.parametersTypes.map(matchW2CRType),
    returnTypeName: returnType,
  };
}

// TODO: workaround a bug(?) that all types are returned as either none, u32 or f64
function matchW2CRType(t?: ValueType): string {
  if (!t) {
    return 'void';
  }

  if (t.startsWith('u') || t.startsWith('i')) {
    return 'u32';
  }
  return 'f64';
}

{% render "header.liquid" %}
#include "jsi-exports-bridge.h"
#include <ReactNativeWebAssembly/Memory.h>
#include <ReactNativeWebAssembly/NativeStates.h>
#include "wasm-rt.h"

#define HOSTFN(name, argCount)         \
jsi::Function::createFromHostFunction( \
rt, \
jsi::PropNameID::forAscii(rt, name), \
argCount, \
[=](jsi::Runtime &rt, const jsi::Value &thisValue, const jsi::Value *args, size_t count) -> jsi::Value


namespace facebook::react {

{%- capture ctx_class %}{{ moduleName | mangle_module_name | capitalize }}ModuleContext{% endcapture %}
{%- capture turbo_module_name %}ReactNative{{ moduleName | mangle_module_name | capitalize }}{% endcapture %}

std::shared_ptr<{{ ctx_class }}> tryGetContext(jsi::Runtime& rt, const jsi::Object& obj) {
  if (!obj.hasNativeState(rt)) {
    return nullptr;
  }

  return std::dynamic_pointer_cast<{{ ctx_class }}>(obj.getNativeState(rt));
}

jsi::Object create{{ moduleName | mangle_module_name | capitalize }}Exports(jsi::Runtime &rt, jsi::Object&& importObject) {
  jsi::Object mod { rt };

  if (!wasm_rt_is_initialized()) {
    wasm_rt_init();
  }

  auto inst = std::make_shared<{{ ctx_class }}>(rt, std::move(importObject));
  {% capture initArgs -%}
    {%- for importedModuleName in importModuleNames -%}
      , &inst->import{{ importedModuleName | mangle_module_name }}Ctx
    {%- endfor %}
  {%- endcapture -%}
  wasm2c_{{ moduleName | mangle_module_name }}_instantiate(&inst->rootCtx{{ initArgs }});

  mod.setNativeState(rt, inst);

  // Memories
  jsi::Object memories {rt};

  {% for export in exportedMemories %}
  /* exported memory: '{{ export.name }}' */
  {
    jsi::Object holder {rt};
    auto memory = std::make_unique<Memory>(w2c_{{ moduleName | mangle_module_name }}_{{ export.name | mangle_name }}(&inst->rootCtx));
    holder.setNativeState(rt, std::make_shared<MemoryNativeState>(std::move(memory)));
    memories.setProperty(rt, "{{ export.name }}", std::move(holder));
  }
  {% endfor %}

  mod.setProperty(rt, "memories", std::move(memories));

  // Exported functions
  jsi::Object exports {rt};

  {% for export in exportedFunctions %}
    /* export: '{{ export.name }}' */
    exports.setProperty(rt, "{{ export.name }}", HOSTFN("{{ export.name }}", {{ export.params.size }}) {
      auto nativeState = tryGetContext(rt, thisValue.getObject(rt));
      {%- capture args -%}
        {%- for arg_name in export.params -%}
          , args[{{ forloop.index0 }}].asNumber()
        {%- endfor %}
      {%- endcapture %}
      {% if export.hasReturn -%}
      auto res =
      {%- endif -%}

    {{ export.generatedCFunctionName }}(&nativeState->rootCtx{{ args }});

      {% if export.hasReturn -%}
        return jsi::Value { (double)res };
      {%- else -%}
        return jsi::Value::undefined();
      {%- endif %}
    }));
  {% endfor %}

  exports.setNativeState(rt, inst);
  mod.setProperty(rt, "exports", std::move(exports));

  return std::move(mod);
}

}
